<?xml version="1.0" encoding="utf-8"?>

<!-- RockRoll.mxml -->
<!-- Copyright (c) 2012 by University of Massachusetts and contributors -->
<!-- Project information: http://srri.umass.edu/datagames/ -->
<!-- Released under the MIT License http://www.opensource.org/licenses/mit-license.php -->

<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" height="400" width="800"
			   xmlns:default="noisy.*"
			   creationComplete="testFlashPlayer()"
			   activate="ScriptInterface.signalActivation()" 
			   deactivate="ScriptInterface.signalDeactivation()"
			   backgroundAlpha="1.0"> 

	<fx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			import com.kcpt.scriptInterface.ScriptInterface;
			
			import common.ParkMiller;
			import common.VersionChecker;
			
			import flash.display.Sprite;
			import flash.errors.ScriptTimeoutError;
			import flash.events.MouseEvent;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.effects.Parallel;
			import mx.effects.Sequence;
			import mx.events.EffectEvent;
			import mx.events.SliderEvent;
			import mx.managers.CursorManager;
			import mx.managers.PopUpManager;
			
			import noisy.GameLevelWindow;
			
			import spark.effects.Move;
			import spark.effects.Rotate;
			import spark.effects.easing.IEaser;
			import spark.effects.easing.Linear;
			import spark.effects.easing.Sine;
			import spark.events.IndexChangeEvent;
			
			// BUILD FOR TinkerPlots or DG: 
			// edit true/false and rebuild to create a new build for each.
			// export the DG version to ./bin-release
			// export the TinkerPlots version to ./bin-release-tp
			private static const MINIMUM_REQUIREMENTS:Number = 11.6;	//the oldest version of flash player you can play this game on.
			
			private static const kUseDataGamesInterface:Boolean = true; // if TRUE use DG edition data interfaces, else use TinkerPLots 2.0-compatible data interface
			public static const VERSION:String = "Rock Roll v.2013.06.04";
			public static const TP_suffix:String = " (fl-tp)" // edition: flash for TinkerPlots
			public static const DG_suffix:String = " (fl-dg)" // edition: flash for DG
			private function getVersion():String {
				return( VERSION + (kUseDataGamesInterface ? DG_suffix : TP_suffix ));
			}
			
			public static const NUMBER_OF_ROCKS:uint	= 16;	// Number of rocks total
			public static const ROCKS_TO_ROLL:uint		= 4;	// How many rocks to roll at once

			// Color to use when disabling text associated with controls.
			public static const DISABLED_TEXT_COLOR:uint= 0x4E594E;	
			public static const ENABLED_TEXT_COLOR:uint	= 0x000000;	
			
			// Sort choices
			public static const DO_NOT_SORT:uint		= 0;
			public static const SORT_BY_COLOR:uint		= 1;
			public static const SORT_BY_PATTERN:uint	= 2;
			public static const SORT_BY_SHAPE:uint		= 3;
			public static const SORT_BY_SIZE:uint		= 4;
			
			// Game levels
			public static const kLevelOne:uint			= 1;			// First game level.
			public static const kLevelTwo:uint			= 2;			// Second game level.
			public static const kLevelOneLabel:String	= "Level One"	// Level one label.
			public static const kLevelTwoLabel:String	= "Level Two"	// Level two label.
			
			public static const kEventsCollectionName:String = "Rolls";
			public static const kGamesCollectionName:String = "Games";
				
			// Standard deviations for top and bottom courts.
			public static const kStdDeviationA:Number	= 6.7;
			public static const kStdDeviationB:Number	= 22;
			
			// Data state for mLastGameOpenState
			public static const kGameDataNotYetOpen:uint = 0;
			public static const kGameDataOpened:uint = 1;
			public static const kGameDataClosed:uint = 2;
			
			
			private var mRandomNormal:ParkMiller;			// Class that creates a uniform normal distribution.
			private var mLevelWindow:GameLevelWindow;		// The modal window for choosing a game level.
			private var mRockArray:Array;					// Array holding rocks played in game.
			private var mRollDataArray:Array;				// Array holding one game's worth of individual roll data.
			private var mStrengthArray:Array;				// Array holding one game's worth of strength values.
			private var mGameLevel:uint				= 1;	// Current game level.
			private var mPrevLevel:uint				= 1;	// Used to track level changes.
			private var mStrengthArrayLength:Number	= 0;	// Length of strength arrays.
			private var mNextRockToRoll:uint		= 0;	// Next rock in queue to roll.
			private var mNextRockToSend:uint		= 0;	// Next rock in queue to send to DG/TinkerPlots (always <= mNextRockToRoll).
			private var mMostRecentRockRolled:uint	= 0;	// Keeps track of most recent rock rolled (0 based like mNextRockToRoll).
			private var mMostRecentGamePlayed:uint	= 0;	// Keeps track of most recent game played (1 based).
			private var mCurrentGameScore:uint		= 0;	// Game score so far.
			private var mTopGameScore:uint			= 0;	// Game score of top court so far.
			private var mBottomGameScore:uint		= 0;	// Game score of bottom court so far.
			private var mCurrentAverageScore:uint	= 0;	// Average score used in autoplay mode.
			private var mStartY:Number				= 32; 	// Starting Y position for first rock.
			private var mOffsetY:Number				= 16; 	// Y distance between rocks.
			private var mCurrentGameSinceLaunch:uint= 1;	// Track game number for data tracking. Starts at 1.
			private var mLastGameOpened:uint		= 0;	// Track game number last used by sendGameDataOpen()
			private var mLastGameOpenState:uint		= kGameDataClosed;	// Track game state for sendGameDataOpen(), sendGameDataClose(), etc.
			private var mPlayAutomatically:Boolean	= false;// Flag to specify current play mode.
			private var mRocksAreRolling:Boolean	= false;// Flag true while rocks are rolling.
			private var mRollRocksButtonDown:Boolean= false;// Flag true while roll rocks button is down.
			private var mCancelButtonOn:Boolean		= false;// Flag is on after New Game button has been pressed.
			private var mRollCounter:uint			= 0;	// Counter used for current number of rolls that have played.
															// 		Used by onRockRollComplete.
			private var mRollReturnCounter:uint		= 0;	// Counter used for current number of rolls that have 
															// 		completed their return to the start.
															// 		Used by onRockReturnComplete.
			private	var	parentCaseID:int = 0;
			
			// Info about the 2 distributions used for the top and bottom shuffle courts.
			private var mStdDeviationA:Number	= kStdDeviationA;
			private var mStdDeviationB:Number	= kStdDeviationB;
			private var mMeanA:Number			= 45;
			private var mMeanB:Number			= 25;
			
			public var playBtn:MovieClip;
			
			[Bindable]
			public var sortList:ArrayCollection = new ArrayCollection(
				[	{text:"Unsorted",	choice:DO_NOT_SORT},
					{text:"Color",		choice:SORT_BY_COLOR},
					{text:"Pattern",	choice:SORT_BY_PATTERN},
					{text:"Shape",		choice:SORT_BY_SHAPE},
					{text:"Size",		choice:SORT_BY_SIZE} 
				]
			);
			
			// test flash player makes sure the player is meeting the minimum requirements.
			private function testFlashPlayer():void
			{
				if(VersionChecker.isValid( MINIMUM_REQUIREMENTS))
				{
					startUp();
				} else {
					BrickWall.visible = true;
				}
			}
			
			// startUp() is called when the creation of this class is complete
			// and sets up necessary parameters for game initiation.
			private	function startUp():void	
			{
				mRandomNormal = new ParkMiller();	// Create class that generates a uniform normal distribution.
				var sliderStartValue:Number	= 50;	// Start value of strength sliders.
				var stepperStartValue:Number= 1;	// Start value if number of games to play.
				
				mStrengthSliderA.value		= sliderStartValue;
				this.changeStrengthA();					// Update the slider label.
				enableStrengthSliderAAndLabel(false);	// Disable the slider and label.
				mStrengthSliderB.value		= sliderStartValue;
				this.changeStrengthB();					// Update the slider label.
				
				// Per-roll strengths are saved for game data transmission to TinkerPlots/Fathom.
				mStrengthArrayLength	= Math.ceil(NUMBER_OF_ROCKS/ROCKS_TO_ROLL);
				mStrengthArray			= new Array(mStrengthArrayLength);
				
				enableStrengthSliderBAndLabel(false);	// Disable the slider and label.
				mNumberGamesStepper.value	= stepperStartValue;
				this.updateNumberOfGames();				// Update the stepper label.
				enableNumberGamesStepperAndLabel(false);// Disable stepper at start.
				mInstructionsLabel.text 	= "Press 'New Game' Button to Begin";
				enableAutoPlayCheckBoxAndLabel(false);	// Disable autoplay checkbox and label.
				enableSortRocksList(false);		// Disable sort rocks list and label.
				
				// Event listeners can go here. 
				// A disadvantage is that placing the listeners here instead of in the MXML at 
				// the end of the file will mean that in Design mode, one will not instantly be 
				// able to see the name of the event handler.
//				this.rollRocksButton.addEventListener(MouseEvent.CLICK, this.onRollRocks );
				this.mRollRocksButton.addEventListener(MouseEvent.MOUSE_OUT, this.onRollRocksMouseOut);
				this.mRollRocksButton.addEventListener(MouseEvent.MOUSE_OVER, this.onRollRocksMouseOver);
				
				this.updateStrengthSliders();
				this.updateCourtMarkings();
				
				// Create the rocks used in every game iteration. There are 16 rocks, each with
				// 4 attributes, and each attribute has only two options, for a total of 16
				// unique rocks that together represent each possible combination.
				var startX:Number	= this.shuffleCourt.mDistanceStartRuleTop.x;
				mStartY				= 32; 		// Starting Y position for first rock.
				var currentY:Number	= mStartY;	// Y position for current rock in following for loops. 
				mOffsetY			= 16; 		// Y distance between rocks.
				mRockArray			= new Array();
				
				for (var i:uint = 0; i < NUMBER_OF_ROCKS; ++i, currentY += mOffsetY) 
				{ 
					// Pass in i as the attribute flag parameter, as there are exactly
					// 16 permutations of 4 attributes with on of two choices. 0 through
					// 15 will result in correct bitflags for each of the permutations.
					var rock:ShuffleRock = new ShuffleRock(i);
					rock.setPosition(startX, currentY);
					mRockArray.push(rock); 				// add rock to array
					this.shuffleCourt.addElement(rock); // add rock as element so it can be drawn
				} 				
				
				// Data for each roll is saved until the game is complete before transmitting to 
				// TinkerPlots/Fathom.
				mRollDataArray		= new Array(NUMBER_OF_ROCKS);
				
				
				this.randomizeRockOrder();	// Randomize order of rock array.
				this.drawAllRocks();		// Draw rocks in their initial starting places.
				
				mNextRockToRoll			= 0;	// Start with first rock.
				mNextRockToSend			= 0;	// Start with first rock.
				mMostRecentRockRolled	= 0;	// Keep track of most recent rock rolled.
				mMostRecentGamePlayed	= 0;	// Keep track of most recent game played.
				mPlayAutomatically		= false;// Start in non-batch mode.
				mRocksAreRolling		= false;// Rocks are not rolling yet.
				mRollRocksButtonDown	= false;// Flag true while roll rocks button is down.
				mCancelButtonOn			= false;// Flag is off until New Game button has been pressed.
				mRollCounter			= 0;	// No rolls displayed yet.
				mRollReturnCounter		= 0;	// No rocks returning to start yet.
				mCurrentGameScore		= 0;	// Game begins at zero.
				mTopGameScore			= 0;	// Game begins at zero.
				mBottomGameScore		= 0;	// Game begins at zero.
				mCurrentAverageScore	= 0;	// Zero out average score used in autoplay mode.
				
				sendCollectionData();
			}
			
			//casts content of SWFLoader as a movieclip when its done loading, and adds listener 
			private function initPlayButton():void{
				playBtn = playButton.content as MovieClip;
				playBtn.addEventListener(MouseEvent.CLICK, gameLevelHandler);
			}
			
			//handler for play button in intro video. gets rid of intro movie and play button, and starts with level 1
			private function gameLevelHandler(e:MouseEvent):void{
				setLevelOne(e); //sends fake click to levelOne listener
				MovieContainer.removeElement(introMovie);
				MovieContainer.removeElement(playButton);
				this.removeElement(MovieContainer);
				}

			// Set up the game data to send to DG or TinkerPlots.  The collections are the tables of cases and attributes.
			private	function sendCollectionData():void	{
				var	result:String;
				
				if( kUseDataGamesInterface ) 
				{	// use the DG-compatible data interface for extra functionality; not compatible with TinkerPlots 2.0 Research Edition	
					var initGameObj:Object = {
						action: "initGame",
						args: {
							name: "Rock Roll",
							dimensions: { width: this.width, height: this.height },
							collections: [
								{
									name: kGamesCollectionName,
									attrs:[
										{name: "GameNumber", type: "nominal", precision: 0, description: "Game number"   } , 
										{name: "Score_Total", type: "numeric", precision: 0, description: "Total score for completion of game"   } ,	
										{name: "Score_Top", type: "numeric", precision: 0, description: "Sub score for rolls 1-8"   } ,	
										{name: "Score_Bottom", type: "numeric", precision: 0, description: "Sub score for rolls 9-16"   } ,	
										{name: "Sorted_By", type: "nominal", description: "Type by which rocks are sorted, if any"   } ,
										{name: "Top_Strength", type: "numeric", precision: 0, description: "Use in autplay mode for strength of rolls 1-8"   } ,	
										{name: "Top_1to4_Strength", type: "numeric", precision: 0, description: "Strength used to roll rocks on top half of court for rolls 1-4"   } ,	
										{name: "Top_5to8_Strength", type: "numeric", precision: 0, description: "Strength used to roll rocks on top half of court for rolls 5-8"   } ,	
										{name: "Bottom_Strength", type: "numeric", precision: 0, description: "Use in autplay mode for strength of rolls 9-16"   } ,	
										{name: "Bottom_9to12_Strength", type: "numeric", precision: 0, description: "Strength used to roll rocks on bottom half of court for rolls 9-12"   } ,	
										{name: "Bottom_13to16_Strength", type: "numeric", precision: 0, description: "Strength used to roll rocks on bottom half of court for rolls 13-16"   }
									] ,
									childAttrName: "game_record"
								},
								{
									name: kEventsCollectionName,
									attrs:	[
										{name: "GameNumber", type: "nominal", precision: 0, description: "Game number"   } , 
										{name: "RollOrder", type: "numeric", precision: 0, description: "Roll order within the game"   } ,	
										{name: "Court", type: "nominal", description: "Top or bottom court"   } ,	
										{name: ShuffleRock.COLOR_STRING, type: "nominal", description: "Color of rock",   
											colormap: {	
													"Red" : 'red', 
													"Blue" : 'blue'
											}} ,
										{name: ShuffleRock.PATTERN_STRING, type: "nominal", description: "Pattern on rock"   } ,
										{name: ShuffleRock.SHAPE_STRING, type: "nominal", description: "Shape of rock"   } ,
										{name: ShuffleRock.SIZE_STRING, type: "nominal", description: "Size of rock"   } ,
										{name: "Strength", type: "numeric", precision: 0, description: "Strength of roll"   } ,
										{name: "Distance", type: "numeric", precision: 0, description: "Distance rocked reached once it stopped rolling"   } ,
										{name: "RollScore", type: "numeric", precision: 0, description: "Score earned by this roll of the rock"   } 
									],
									labels: {
										singleCase: "roll",
										pluralCase: "rolls",
										singleCaseWithArticle: "a roll",
										setOfCases: "game events",
										setOfCasesWithArticle: "the game events"
									},
									defaults: { xAttr: "Distance", yAttr: "Court" }
								}
							] // collections
						} // args
					}; //initGameObj
					var	initGameString:String = JSON.encode( initGameObj );
					result = ScriptInterface.doCommand( initGameString );
				}
				else {
					// use the old data interface compatible with TinkerPlots 2.0 Research Edition; 
					// works less well with DG, does not give game dimensions, does not identify numeric/categorical type of attributes, etc.
					ScriptInterface.NewCollectionWithAttributes(
						kEventsCollectionName,
						[
							"GameNumber",	// Game number starting with 1 since launch of application.
							"RollOrder",	// Roll order within the current game being played.
							"Court",		// Top or bottom court.
							ShuffleRock.COLOR_STRING,	// Name of first attribute, such as "Color"
							ShuffleRock.PATTERN_STRING,	// Name of second attribute, such as "Pattern"
							ShuffleRock.SHAPE_STRING,	// Name of third attribute, such as "Shape"
							ShuffleRock.SIZE_STRING,	// Name of fourth attribute, such as "Size"
							"Strength", 				// Strength at which this roll was executed.
							"Distance", 				// Distance rocked reached once it stopped rolling.
							"RollScore"]				// Score earned by this roll of the rock.
					);
					
					ScriptInterface.NewCollectionWithAttributes(
						kGamesCollectionName,
						[	"GameNumber",		// Game number starting with 1 since launch of application.
							"Score_Total", 	// Total score for completion of this single game.
							"Score_Top",	// Sub score for rolls 1-8
							"Score_Bottom",	// Sub score for rolls 9-16.
							"Sorted_By",			// Type by which rocks are sorted, if any.
							"Strength_Top",			// Use in autplay mode for strength of rolls 1-8.
							"Strength_Top_1to4",	// Strength used to roll rocks on top half of court for rolls 1-4.
							"Strength_Top_5to8",	// Strength used to roll rocks on top half of court for rolls 5-8.
							"Strength_Bottom",		// Use in autplay mode for strength of rolls 9-16.
							"Strength_Bottom_9to12",	// Strength used to roll rocks on bottom half of court for rolls 9-12.
							"Strength_Bottom_13to16",	// Strength used to roll rocks on bottom half of court for rolls 13-16.
						]
					);
				}
			}
			
			// send the Game-level data to TinkerPlots or DG.
			// this creates and opens the game case, see also sendGameDataClose()
			private function sendGameDataOpen():void 
			{
				if( mLastGameOpenState == kGameDataNotYetOpen ) {
					// open a new game case
					trace("sendGameDataOpen()__ currentGame="+mCurrentGameSinceLaunch+" mLastGameOpened="+mLastGameOpened); // last should be zero

					var vals:Array = [
						mCurrentGameSinceLaunch,
						0,
						0,
						0,
						mSortRocksList.selectedItem.text
					];
					
					if( kUseDataGamesInterface ) { // if DG
						var openGameCaseObj:Object = {
								action: "openCase",
								args: { 
									collection: kGamesCollectionName,
									values: vals
								} 	
							}
						var	resultString:String = ScriptInterface.doCommand( JSON.encode( openGameCaseObj ));
						var resultObj:Object = (resultString ? JSON.decode( resultString ) : null );
						this.parentCaseID = (resultObj && resultObj.success ? resultObj.caseID : -1 );
					} else {
						// else do nothing for TinkerPlots; old game API wants nothing for start of game
					}
				
					// save the game number opened, to help us know when to open a new game with auto-play
					mLastGameOpened = mCurrentGameSinceLaunch;
					mLastGameOpenState = kGameDataOpened;
				}
			}
			
			// Update the game-level case data created by sendGameDataOpen(), by sending an update to TinkerPlots or DG
			private function sendGameDataUpdate():void 
			{
				if( mLastGameOpenState == kGameDataOpened ) {		
				// update the game data (relies on the global values to have changed)
					trace("sendGameDataUpdate() currentGame="+mCurrentGameSinceLaunch+" mLastGameOpened="+mLastGameOpened); // should be equal if game case open
					sendGameDataPrivUpdate( "", "", [undefined,undefined,undefined,undefined], false /* update only */ );
				}
			}
			
			// Close the game-level case data created by sendGameDataOpen(), by sending an update to TinkerPlots or DG
			// relies on certain global values to have changed: mCurrentGameScore, etc.
			private function sendGameDataClose( iStrengthTop:String, iStrengthBottom:String, iStrengthArray:Array ):void
			{
				if( mLastGameOpenState == kGameDataOpened ) {
					// close the game data (relies on the global values to have changed)
					trace("sendGameDataClose()_ currentGame="+mCurrentGameSinceLaunch+" mLastGameOpened="+mLastGameOpened); // should be equal if game case open
					sendGameDataPrivUpdate( iStrengthTop, iStrengthBottom, iStrengthArray, true /* update and close */ );
				
					mLastGameOpened = 0; 					// forget old game case ID
					mLastGameOpenState = kGameDataClosed;	// don't allow updates until new game case opened again
					mCurrentGameSinceLaunch += 1; 			// Game is done and tracked. Increment counter.
				}
			}
						
			// Send the Game-level data to TinkerPlots or DG.
			// this updates or closes the game case created by sendGameDataOpen() or sendGameDataUpdate()
			// relies on certain global values to have changed: mCurrentGameScore, etc.
			private function sendGameDataPrivUpdate( iStrengthTop:String, iStrengthBottom:String, iStrengthArray:Array, wantCaseClosed:Boolean = true ):void
			{
				var vals:Array = [
							mCurrentGameSinceLaunch,
							mCurrentGameScore,
							mTopGameScore,
							mBottomGameScore,
							mSortRocksList.selectedItem.text,
							iStrengthTop,
							iStrengthArray[0],
							iStrengthArray[1],
							iStrengthBottom,
							iStrengthArray[2],
							iStrengthArray[3]
						];
			
				if( kUseDataGamesInterface ) { // if DG 
					var	closeGameCaseObj:Object = { 
							action: (wantCaseClosed ? "closeCase" : "updateCase" ),
							args: { 
								collection: kGamesCollectionName,
								caseID: this.parentCaseID,
								values: vals
							}
						};
					ScriptInterface.doCommand( JSON.encode( closeGameCaseObj ));
				} 
				else { // TinkerPlots 2.0 Research Edition interface
					if( wantCaseClosed ) { // no update possible in TinkerPlots interface
					ScriptInterface.AddCaseToCollectionWithValues(
						kGamesCollectionName, 
						vals );
				}
			}
			}
			
			// send the Event-level data to TinkerPlots or DG.
			private function sendEventData( iRollsArray:Array, iStartIndex:int, iEndIndex:int ):void 
			{
				if( mLastGameOpenState != kGameDataOpened ) {
					trace("sendEventData() ignored because game data case is not open");
					return;
				}
				trace("sendEventData() "+iStartIndex+" to "+iEndIndex+" for game "+mLastGameOpened);
				var arrayOfEvents:Array = [];
				for (var rollIndex:Number = iStartIndex; rollIndex < iEndIndex; ++rollIndex)
				{
					//trace("sendEventData() adding roll "+iRollsArray[rollIndex].mRollOrder);
					var oneEvent:Array = [
						iRollsArray[rollIndex].mGameNumber,
						iRollsArray[rollIndex].mRollOrder,
						iRollsArray[rollIndex].mCourt,
						iRollsArray[rollIndex].mColorString,
						iRollsArray[rollIndex].mPatternString,
						iRollsArray[rollIndex].mShapeString,
						iRollsArray[rollIndex].mSizeString,
						iRollsArray[rollIndex].mStrength,
						iRollsArray[rollIndex].mDistance,
						iRollsArray[rollIndex].mRollScore
					];
					arrayOfEvents.push( oneEvent );
				}
				if( kUseDataGamesInterface ) { // DG interface
					var createEventCaseObj:Object = {
						action: "createCases",
						args: {
							collection: kEventsCollectionName,
							parent: this.parentCaseID,
							values: arrayOfEvents
						}
					};
					ScriptInterface.doCommand( JSON.encode( createEventCaseObj ));
				}
				else { // TinkerPlots interface
					for (var eventIndex:int = 0; eventIndex < arrayOfEvents.length; ++eventIndex) 
					{
						ScriptInterface.AddCaseToCollectionWithValues( 
							kEventsCollectionName, 
							arrayOfEvents[ eventIndex ]
						);
					}
				}
			}
			
			// enableAutoPlayCheckBoxAndLabel() enables/disables the autoplay checkbox
			// and associated label.
			protected function enableAutoPlayCheckBoxAndLabel(iEnable:Boolean):void
			{
				mAutoPlayCheckBox.enabled	= iEnable;	// Enable/disable autoplay check box.
				// Enable/disable text associated with autoplay checkbox.
				mAutoPlayLabel.setStyle("color", iEnable ? ENABLED_TEXT_COLOR : DISABLED_TEXT_COLOR); 
			}
			
			// enableNumberGamesStepperAndLabel() enables/disables the number of games stepper
			// and associated label.
			protected function enableNumberGamesStepperAndLabel(iEnable:Boolean):void
			{
				mNumberGamesStepper.enabled	= iEnable;	// Enable/disable number of games stepper.
				// Enable/disable text associated with number of games stepper.
				mNumberGamesStepperLabel.setStyle("color", iEnable ? ENABLED_TEXT_COLOR : DISABLED_TEXT_COLOR); 
			}
			
			// enableSortRocksList() enables/disables the sort rocks list
			protected function enableSortRocksList(iEnable:Boolean):void
			{
				mSortRocksList.enabled	= iEnable;	// Enable/disable sort rocks list.
			}
			
			// enableStrengthSliderAAndLabel() enables/disables the strength slider A
			// and associated label.
			protected function enableStrengthSliderAAndLabel(iEnable:Boolean):void
			{
				mStrengthSliderA.enabled	= iEnable;	// Enable/disable strength slider A.
				// Enable/disable text associated with strength slider A.
				mStrengthLabelA.setStyle("color", iEnable ? ENABLED_TEXT_COLOR : DISABLED_TEXT_COLOR); 
			}
			
			// enableStrengthSliderBAndLabel() enables/disables the strength slider B
			// and associated label.
			protected function enableStrengthSliderBAndLabel(iEnable:Boolean):void
			{
				mStrengthSliderB.enabled	= iEnable;	// Enable/disable strength slider A.
				// Enable/disable text associated with strength slider A.
				mStrengthLabelB.setStyle("color", iEnable ? ENABLED_TEXT_COLOR : DISABLED_TEXT_COLOR); 
			}
			
			// chooseGameLevel() listens for clicks on the level dialog's level buttons.
			private function chooseGameLevel():void 
			{
				var isModal:Boolean = true;
				PopUpManager.addPopUp(mLevelWindow, this, isModal);
				
				PopUpManager.centerPopUp(mLevelWindow);		// Center the window.
				mLevelWindow.closeButton.visible = false;	// Hide the close button.
				
				mLevelWindow["mLevelOneButton"].addEventListener("click", setLevelOne);   
				mLevelWindow["mLevelTwoButton"].addEventListener("click", setLevelTwo);   
			}

			// gameLevelChosen() sets the current game level to the value passed in and closes the modal
			// dialog.
			private function gameLevelChosen(iLevel:uint):void 
			{
				mGameLevel = iLevel; // Set game level to practice.
				
				PopUpManager.removePopUp(mLevelWindow);
			}

			// setLevelOne() sets the current game level to level one.
			private function setLevelOne(iEvent:Event):void 
			{
				mPrevLevel = mGameLevel;		// Track game level change.
				
				// If changing levels, perform any level-changing tasks.
//				if (mGameLevel != kLevelOne)
				{
					// The first level only has the two courts differ by mean, not 
					// standard deviation.
					mStdDeviationB = kStdDeviationA;
				}
				
				gameLevelChosen(kLevelOne); // Set game level.
				mLevelLabel.text = kLevelOneLabel;
			}
						
			// setLevelTwo() sets the current game level to level two.
			private function setLevelTwo(iEvent:Event):void 
			{
				mPrevLevel = mGameLevel;		// Track game level change.
				
				// If changing levels, perform any level-changing tasks.
//				if (mGameLevel != kLevelTwo)
				{
					// The second level uses different standard deviations for the top and
					// bottom courts.
					mStdDeviationB = kStdDeviationB;
				}
				
				gameLevelChosen(kLevelOne); // Set game level.
				mLevelLabel.text = kLevelTwoLabel;
			}
			
			// drawAllRocks() draws all rocks according their current settings.
			protected function drawAllRocks():void
			{
				for (var i:Number = 0; i < NUMBER_OF_ROCKS; ++i) 
					mRockArray[i].drawMe();
			}
		
			// hideAllRocks() hides all rocks.
			protected function hideAllRocks():void
			{
				for (var i:Number = 0; i < NUMBER_OF_ROCKS; ++i) 
				{
					mRockArray[i].hideMe();
				}		
			}
			
			// redrawAllRocks() redraws all rocks according to their current settings.
			protected function redrawAllRocks():void
			{
				for (var i:Number = 0; i < NUMBER_OF_ROCKS; ++i) 
				{
					mRockArray[i].drawMe();
				}		
			}
			
			// randomizeRockOrder() randomizes the order of the rock array.
			protected function randomizeRockOrder():void
			{
				var j:Number = 0;
				var temp:ShuffleRock;
				
				for (var i:Number = 0; i < NUMBER_OF_ROCKS; ++i) 
				{
					// Do the random swap.
					j = Math.floor(Math.random() * (i + 1));
					temp = mRockArray[i];
					mRockArray[i] = mRockArray[j];
					mRockArray[j] = temp;
					
					// Set the y position to follow the array order. Otherwise, the 
					// swapped rocks will still be drawn in the same position as before 
					// the swap.
					mRockArray[i].setPositionY(mStartY + (i * mOffsetY));
					mRockArray[j].setPositionY(mStartY + (j * mOffsetY));
				}
			}
			
			// sortRockArray() sorts the rock array by the passed in sort attribute.
			protected function sortRockArray(iSortBy:uint):void
			{
				var sortField:String;
				
				switch (iSortBy)
				{
					case SORT_BY_COLOR:
						mRockArray.sortOn("mColor", Array.DESCENDING);
						break;
					case SORT_BY_PATTERN:
						mRockArray.sortOn("mPattern", Array.DESCENDING);
						break;
					case SORT_BY_SHAPE:
						mRockArray.sortOn("mShape", Array.DESCENDING);
						break;
					case SORT_BY_SIZE:
						mRockArray.sortOn("mSize", Array.DESCENDING);
						break;
					default:
						return;	// Don't sort if no valid sort attribute.
				}
			
				// Set the y position to follow the array order. Otherwise, the 
				// swapped rocks will still be drawn in the same position as before 
				// the swap.
				for (var i:Number = 0; i < NUMBER_OF_ROCKS; ++i) 
					mRockArray[i].setPositionY(mStartY + (i * mOffsetY));
			}
			
			// updateStrengthSliders() updates the slider text.
			protected function updateStrengthSliders():void
			{
				// Updates the text beneath the sliders.
				changeStrengthA();
				changeStrengthB();
			}
			
			// updateNumberOfGames() records the number of games in the stepper
			// control, updates any text that relates to this change, and sets
			// any flags corresponding to the playing of multiple games at once.
			protected function updateNumberOfGames():void
			{
				var numberOfGames:Number = mNumberGamesStepper.value;
				
				if (mPlayAutomatically) 		
				{
					var repetionString:String = "";
					
					switch (numberOfGames)
					{
						case 1:
							repetionString = " Once";
							break;
						case 2:
							repetionString = " Twice";
							break;
						default:
							repetionString = " " + numberOfGames + " Times";
						break;
					}
						
					mRollRocksButton.label = "Play" + repetionString;
				}
				else
					mRollRocksButton.label	= "Roll Rocks";
				
				// Update instructions text.
				updateInstructionsText();
			}
			
			// updateCourtMarkings() updates the text in the shuffle court according
			// too the selected sort method.
			protected function updateCourtMarkings():void
			{
				switch (mSortRocksList.selectedIndex)
				{
					case SORT_BY_COLOR:
						shuffleCourt.mLaneTextA.text = ShuffleRock.COLOR_RED_STRING;
						shuffleCourt.mLaneTextB.text = ShuffleRock.COLOR_BLUE_STRING;
						break;
					case SORT_BY_PATTERN:
						shuffleCourt.mLaneTextA.text = ShuffleRock.PATTERN_STRIPED_STRING;
						shuffleCourt.mLaneTextB.text = ShuffleRock.PATTERN_SOLID_STRING;
						break;
					case SORT_BY_SHAPE:
						shuffleCourt.mLaneTextA.text = ShuffleRock.SHAPE_BALL_STRING;
						shuffleCourt.mLaneTextB.text = ShuffleRock.SHAPE_CUBE_STRING;
						break;
					case SORT_BY_SIZE:
						shuffleCourt.mLaneTextA.text = ShuffleRock.SIZE_SMALL_STRING;
						shuffleCourt.mLaneTextB.text = ShuffleRock.SIZE_LARGE_STRING;
						break;
					default:
						shuffleCourt.mLaneTextA.text = ShuffleCourt.LANE_A_DEFAULT_STRING;
						shuffleCourt.mLaneTextB.text = ShuffleCourt.LANE_B_DEFAULT_STRING;
						break;
				}
			}
			
			// changeStrengthA() updates the text associated with strength slider A.
			protected function changeStrengthA():void
			{
				var strengthString:String;
				
				switch (mSortRocksList.selectedIndex)
				{
					case SORT_BY_COLOR:
						strengthString = "Strength for " + ShuffleRock.COLOR_RED_STRING + " Rocks = ";
						break;
					case SORT_BY_PATTERN:
						strengthString = "Strength for " + ShuffleRock.PATTERN_STRIPED_STRING + " Rocks = ";
						break;
					case SORT_BY_SHAPE:
						strengthString = "Strength for " + ShuffleRock.SHAPE_BALL_STRING + " Rocks = ";
						break;
					case SORT_BY_SIZE:
						strengthString = "Strength for " + ShuffleRock.SIZE_SMALL_STRING + " Rocks = ";
						break;
					default:
						strengthString = "Strength for " + ShuffleCourt.LANE_A_DEFAULT_STRING + " Rocks = ";
						break;
				}
				
				mStrengthLabelA.text = strengthString + mStrengthSliderA.value;
			}			

			// changeStrengthB() updates the text associated with strength slider B.
			protected function changeStrengthB():void
			{
				var strengthString:String;
				
				switch (mSortRocksList.selectedIndex)
				{
					case SORT_BY_COLOR:
						strengthString = "Strength for " + ShuffleRock.COLOR_BLUE_STRING + " Rocks = ";
						break;
					case SORT_BY_PATTERN:
						strengthString = "Strength for " + ShuffleRock.PATTERN_SOLID_STRING + " Rocks = ";
						break;
					case SORT_BY_SHAPE:
						strengthString = "Strength for " + ShuffleRock.SHAPE_CUBE_STRING + " Rocks = ";
						break;
					case SORT_BY_SIZE:
						strengthString = "Strength for " + ShuffleRock.SIZE_LARGE_STRING + " Rocks = ";
						break;
					default:
						strengthString = "Strength for " + ShuffleCourt.LANE_B_DEFAULT_STRING + " Rocks = ";
						break;
				}
				
				mStrengthLabelB.text = strengthString + mStrengthSliderB.value;
			}
			
			// updateInstructionsText() updates the text that helps the user know what to do next.
			protected function updateInstructionsText():void
			{
				if (!mCancelButtonOn || (mMostRecentRockRolled + 1 == NUMBER_OF_ROCKS))
					// Most recent game is over or user pressed 'Cancel'. Instruct user to press 
					// 'New Game' button. 
					mInstructionsLabel.text = "Press 'New Game' Button to Begin";
				else
				{
					// In mid-game. Instruct user to press mRollRocksButton button.
					if (mPlayAutomatically)
						mInstructionsLabel.text = "Press 'Play...' Button to Continue";
					else
						mInstructionsLabel.text = "Press '" + mRollRocksButton.label + "' Button to Continue";
				}
			}
			
			// onRockRollComplete() is used to handle the enabling of buttons only after 
			// the rock rolling effects have completed. Otherwise, pressing a button during 
			// and effect that is still playing can have unwanted results.
			protected function onRockRollComplete(iEvent:EffectEvent):void
			{
				trace("onRockRollComplete()");
				mNewGameButton.enabled	= true;
				mRollCounter += 1;
				
				if (mPlayAutomatically)
				{
					if (mRollCounter == NUMBER_OF_ROCKS)
					{
						mRocksAreRolling		= false;// Rolling has stopped.
						mRollCounter			= 0;	// Reset counter.
						
						// Enable new game button, now that current game is over.
						mNewGameButton.enabled	= true;
						
						// Enable 'Change Level' button, now that current game is over.
						mChangeLevelButton.enabled	= true;
						
						// Toggle 'cancel'/'new game' state and button text.
						toggleCancelButton();
					}
				}
				else	// single game mode
				{
					// ROCKS_TO_ROLL divides evenly into roll counter, so another group of rocks has completed.
					if ((mRollCounter % ROCKS_TO_ROLL) == 0) 
					{
						mRocksAreRolling		= false;	// Rolling has stopped.
						
						// Enable 'New Game'/'Cancel" button.
//						mNewGameButton.enabled	= true;
						
						if (mRollCounter == NUMBER_OF_ROCKS)
						{
							mRollCounter			= 0;	// Reset counter.
							
							// Toggle 'cancel'/'new game' state and button text.
							toggleCancelButton();
							
							// Enable 'New Game'/'Cancel" button.
//							mNewGameButton.enabled	= true;
							
							// Enable 'Change Level" button, now that current game is over.
							mChangeLevelButton.enabled	= true;
						}
						else
						{
							// Enable Roll Rocks button, and strength sliders, if all current 
							// rolls are complete and user did not abort.
							if (mCancelButtonOn)
							{
								mRollRocksButton.enabled	= true;
								enableStrengthSliderAAndLabel(true);
								enableStrengthSliderBAndLabel(true);
							}
						}
						
						if( mLastGameOpenState == kGameDataNotYetOpen ) {
							sendGameDataOpen(); // if not opened by onNewNewGame(), e.g. during auto-play
						}
						sendGameDataUpdate();
					}
				}
				
//				/**
//				 * Code to send small chunks of data to dg at a time
//				 */
//				var intID:uint = setInterval(sendChunk, 500); //sends a chunk of data every 500ms
//				const chunkSize:int = 10;
//				var start:int=1, end:int=chunkSize; //send 10 at a time
//				function sendChunk():void
//				{
//					for (var gameCount:uint = start; gameCount<=end && gameCount <= mNumberGamesStepper.value; ++gameCount)
//					{
//						sendEventData( mRollDataArray, mNextRockToSend, mNextRockToRoll ); // send rocksToRoll events (max is NUMBER_OF_ROCKS)
//						mNextRockToSend = mNextRockToRoll;
//						
//						// Reset "next rock to roll" back to first rock, if we have moved past the end of the rocks.
//						if (mNextRockToRoll >= NUMBER_OF_ROCKS-1)
//						{
//							mRollRocksButton.enabled	= false;	// Can't roll again until new game button is pressed.
//							enableStrengthSliderAAndLabel(false);	// Can't roll again until new game button is pressed.
//							enableStrengthSliderBAndLabel(false);	// Can't roll again until new game button is pressed.
//							
//							// Set strength values used for transmission to TinkerPlots/Fathom when in
//							// autoplay mode.
//							var strengthTop:String		= ""; 
//							var strengthBottom:String	= ""; 
//							
//							if (mPlayAutomatically)
//							{
//								strengthTop		= mStrengthSliderA.value.toString(); 
//								strengthBottom	= mStrengthSliderB.value.toString(); 
//							}
//							
//							// Send data on this game to TinkerPlots/Fathom/DG.
//							sendGameDataClose( strengthTop, strengthBottom, mStrengthArray );
//							
//							mMostRecentGamePlayed	= gameCount;	// Keep track of most recent game played.
//							mCurrentGameSinceLaunch += 1; 			// Game is done and tracked. Increment counter.
//							mPrevLevel 				= mGameLevel;	// Track game level change.
//						}
//					}
//					
//					start+=chunkSize;
//					end+=chunkSize;
//					if(end>mNumberGamesStepper.value) end=mNumberGamesStepper.value;
//					if(start>=end) clearInterval(intID);
//					if (mNextRockToRoll >= NUMBER_OF_ROCKS)
//					{
//						mNextRockToRoll = 0; // Reset rock back to first rock.
//						mNextRockToSend = 0; // Start with first rock.
//					}
//				} //End sendChunk()
				
				for (var gameCount:uint = 1; gameCount <= mNumberGamesStepper.value; ++gameCount)
				{
					sendEventData( mRollDataArray, mNextRockToSend, mNextRockToRoll ); // send rocksToRoll events (max is NUMBER_OF_ROCKS)
					mNextRockToSend = mNextRockToRoll;
					
					// Reset "next rock to roll" back to first rock, if we have moved past the end of the rocks.
					if (mNextRockToRoll >= NUMBER_OF_ROCKS)
					{
						mRollRocksButton.enabled	= false;	// Can't roll again until new game button is pressed.
						enableStrengthSliderAAndLabel(false);	// Can't roll again until new game button is pressed.
						enableStrengthSliderBAndLabel(false);	// Can't roll again until new game button is pressed.
						
						// Set strength values used for transmission to TinkerPlots/Fathom when in
						// autoplay mode.
						var strengthTop:String		= ""; 
						var strengthBottom:String	= ""; 
						
						if (mPlayAutomatically)
						{
							strengthTop		= mStrengthSliderA.value.toString(); 
							strengthBottom	= mStrengthSliderB.value.toString(); 
						}
						
						// Send data on this game to TinkerPlots/Fathom/DG.
						trace("onRockRollComplete() "+mNextRockToRoll+" rocks");
						sendGameDataClose( strengthTop, strengthBottom, mStrengthArray );
						mMostRecentGamePlayed	= gameCount;	// Keep track of most recent game played.
						//mCurrentGameSinceLaunch += 1; 			// Game is done and tracked. Increment counter.
						mPrevLevel 				= mGameLevel;	// Track game level change.
					}
				}
				
				if (mNextRockToRoll >= NUMBER_OF_ROCKS)
				{
					mNextRockToRoll = 0; // Reset rock back to first rock.
					mNextRockToSend = 0; // Start with first rock.
				}
				
				// Update score to reflect rock(s) just rolled.
				var score:uint = mPlayAutomatically ? mCurrentAverageScore : mCurrentGameScore;

				// Update score text.
				if ((mMostRecentRockRolled + 1) == NUMBER_OF_ROCKS)
				{
					if (mPlayAutomatically)
						mScoreTextLabel.text = "Average Score = " + score;
					else
						mScoreTextLabel.text = "Final Score = " + score;
				}
				else
					mScoreTextLabel.text = "Score = " + score;
				
				updateInstructionsText();			// Update instructions text.
				CursorManager.removeBusyCursor();	// Turn off busy cursor.			
			}
			
			// onRockReturnComplete() is used to handle the enabling of buttons only after 
			// the rock rolling effects have completed following the return of all rocks to
			// their starting places. Otherwise, pressing a button during an effect that 
			// is still playing can have unwanted results.
			protected function onRockReturnComplete(iEvent:EffectEvent):void
			{
				mRollReturnCounter += 1;
				
				if (mRollReturnCounter == NUMBER_OF_ROCKS)
				{
					enableSortRocksList(true);	// Enable sort feature.
					mRollReturnCounter = 0;	// Reset roll counter.
					if(mCancelButtonOn)
						mRollRocksButton.enabled = true;	// Enable "Roll Rocks" button if a game is started
				}
			}
			
			// onRollRocksMouseDown() is called when mRollRocksButton is pressed and handles
			// all actions that must be done before onRollRocksMouseUp() begins.
			protected function onRollRocksMouseDown(iEvent:MouseEvent):void	
			{
				CursorManager.setBusyCursor();	// Show busy cursor while rocks are rolling.
				mRollRocksButtonDown = true;
				stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUp);
			}
				
			// onMouseUp() is called when the mouse is released anywhere. Used to clear
			// any flags on mouse up, even if mouse if off original target.
			private function onMouseUp(iEvent:MouseEvent ):void
			{
				stage.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
				mRollRocksButtonDown = false;
			}
			
			// onRollRocksMouseOver() is called when cursor is over mRollRocksButton 
			// and handles busy cursor.
			protected function onRollRocksMouseOver(iEvent:MouseEvent):void	
			{
				if (mRollRocksButtonDown)
					CursorManager.setBusyCursor();	// Show busy cursor while rocks are rolling.
			}
			
			// onRollRocksMouseOut() is called when the cursor moves out of the mRollRocksButton
			// and handles actions not covered by onRollRocksMouseUp().
			protected function onRollRocksMouseOut(iEvent:MouseEvent):void	
			{
				if (!mRocksAreRolling)
					// Don't show busy cursor if rocks aren't rolling.
					CursorManager.removeBusyCursor();
			}
			
			// errorHandler() is called when there is an error and allows app to do whatever
			// cleanup and/or notification is necessary.
			private function errorHandler(/*iEvent:IOErrorEvent*/):void
			{
				Alert.show(
					"An error has occurred. Data transmitted to TinkerPlots/Fathom may include incomplete games.",
					"Warning!");
				
				// Equivalent of pressing Cancel button. Otherwise, all controls are left in the disabled state.
				cancelPressed();
				
				mRocksAreRolling		= false;// Rolling has stopped.
				mRollCounter			= 0;	// Reset counter.
				
				// Enable new game and 'Change Level' buttons now that current game is over.
				mNewGameButton.enabled		= true;
				mChangeLevelButton.enabled	= true;
				
				// Toggle 'cancel'/'new game' state and button text.
				toggleCancelButton();
				
				// Update instructions text.
				updateInstructionsText();
			}
			
			// onRollRocksMouseUp() is called when mRollRocksButton is released and handles game play
			// associated with rolling rocks on the shuffle court.
			protected function onRollRocksMouseUp(iEvent:MouseEvent):void	
			{
				trace("onRollRocksMouseUp()");
				if(!mPlayAutomatically)
					mRocksAreRolling				= true; // Rock rolling has begun.
				mRollRocksButtonDown			= false;// Button has been released.
				
				// Don't show intermediate rock rolls in batch game play mode.
				var showGamePlay:Boolean	= !mPlayAutomatically; 		
				
				var singleRollDistance:uint		= 0;
				var singleRollScore:uint		= 0;
				var randomNumber:Number			= 0;
				var cumulativeBatchScore:uint	= 0;	// Used in autoplay mode to calculate average score.
				
				mRollRocksButton.enabled	= false;	// Disable Roll Rocks button until rocks are done rolling.
				mNewGameButton.enabled		= false;	// Disable 'Cancel' button until roll animation ends.
				enableAutoPlayCheckBoxAndLabel(false);	// Disable autoplay checkbox and label.
				enableNumberGamesStepperAndLabel(false);// Disable games-to-play counter until new game is started.
				enableSortRocksList(false);		// Disable sort feature until new game is started.
				enableStrengthSliderAAndLabel(false);	// Disable strength slider
				enableStrengthSliderBAndLabel(false);	// Disable strength slider
				
				if(mPlayAutomatically) mNewGameButton.enabled = true;

				if (mNextRockToRoll == 0) 
				{
					mCurrentGameScore	= 0; // Zero out score on new game.
					mTopGameScore		= 0; // Zero out score on new game.
					mBottomGameScore	= 0; // Zero out score on new game.
					
					// Erase all entries in the array holding per-roll data.
					for (var counter:uint = 0; counter < NUMBER_OF_ROCKS; ++counter) 
						mRollDataArray[counter] = null;
					
					// Initialize values in arrays to avoid accessing empty indices when reporting
					// values to TinkerPlots/Fathom, in the event that this code changes.
					for (var strengthIndex:Number = 0; strengthIndex < mStrengthArrayLength; ++strengthIndex)
						mStrengthArray[strengthIndex] = 0;
				}
				
				var rocksToRoll:uint;
				if (mPlayAutomatically)
					rocksToRoll				= NUMBER_OF_ROCKS;	// Roll all rocks in multiple game mode.
				else
					rocksToRoll				= ROCKS_TO_ROLL;	// Roll a fixed number of rocks in non-batch mode.
				
				var tempA:Array = new Array();
				var tempB:Array = new Array();
				
				try
				{
					for (var gameCount:uint = 1; gameCount <= mNumberGamesStepper.value; ++gameCount)
					{
						// Zero out game score before each full game play.
						// Do NOT zero out game score in non-batch mode, as game may still be in play.
						if (mPlayAutomatically)
						{
							mCurrentGameScore	= 0;	
							mTopGameScore		= 0;
							mBottomGameScore	= 0;
							
							// Initialize values in arrays to avoid accessing empty indices when reporting
							// values to TinkerPlots/Fathom, in the event that this code changes.
							for (var index:Number = 0; index < mStrengthArrayLength; ++index)
								mStrengthArray[index] = 0;
						}
						
						// Data for each roll is saved until the game is complete before transmitting to 
						// TinkerPlots/Fathom.
						//var rollDataArray:Array	= new Array(NUMBER_OF_ROCKS);
						
						if(mPlayAutomatically)
						{
							// Send data on this game to TinkerPlots/Fathom/DG.
							if( mLastGameOpenState == kGameDataClosed ) {
								mLastGameOpenState = kGameDataNotYetOpen; // during auto-play start a new game automatically
							}
							if( mLastGameOpenState == kGameDataNotYetOpen ) {
								sendGameDataOpen(); // if not opened by onNewNewGame(), e.g. during auto-play
							}
							sendGameDataUpdate();
						}
						
						// Roll a number of rocks, being sure to stop before end of total number of rocks.
						var i:Number = 0;
						for (i = 0; (i < rocksToRoll) && (mNextRockToRoll < NUMBER_OF_ROCKS); ++i)
						{
							// Distribution of rock distance differs based on rock shape.
							if (mRockArray[mNextRockToRoll].getShape() == "Ball")
								//randomNumber = ((Math.random() - 0.5) * mStdDeviationA) + mMeanA;
								randomNumber = ((mRandomNormal.standardNormal() - 0.5) * mStdDeviationA) + mMeanA;
							else
								// randomNumber = ((Math.random() - 0.5) * mStdDeviationB) + mMeanB;
								randomNumber = ((mRandomNormal.standardNormal() - 0.5) * mStdDeviationB) + mMeanB;
						
							// Use the strength slider associated with the shuffle court on which the rock
							// is rolled.
							// Intentionally making the slider values be half the value used in the strength
							// so that users do not get the idea that the strength number maps to the
							// distance markings on the shuffle court.
							var strength:Number = 0;
							if (mNextRockToRoll < (NUMBER_OF_ROCKS/2))
								strength = mStrengthSliderA.value * 2;
							else
								strength = mStrengthSliderB.value * 2;
							
							var rollDistance:Number =	strength + randomNumber;
							singleRollDistance = rollDistance >= 0 ? rollDistance : 0;	// Roll distance can't be less than zero.
							
							if (singleRollDistance > 215)
								singleRollScore = 0;
							else if (singleRollDistance > 190)
								singleRollScore = 30;
							else if (singleRollDistance > 145)
								singleRollScore = 15;
							else if (singleRollDistance > 100)
								singleRollScore = 5;
							else
								singleRollScore = 0;
													
							mCurrentGameScore += singleRollScore;
							
							var whichCourt:String;
							if ((mNextRockToRoll + 1) <= (NUMBER_OF_ROCKS / 2))
							{
								mTopGameScore += singleRollScore;
								whichCourt = "Top";
							}
							else
							{
								mBottomGameScore += singleRollScore;
								whichCourt = "Bottom";
							}
							
							// Only display game play in a manual (non-AutoPlay) mode or in the final
							// game of a batch, to speed up application time.
							if (gameCount == mNumberGamesStepper.value)
							{
								// Set up the behavior of the rock's motion as it will roll.
								var easeIn:Number		= 0;	// Rock starts rolling quickly.
								var easeOut:Number		= 1;	// Rock motion peters out at the end of the roll.
								var stopSlowly:Linear	= new Linear(easeIn, easeOut);
								var rockMove:Move		= new Move(mRockArray[mNextRockToRoll]);
								rockMove.easer 			= stopSlowly;
								
								// Create a parallel operation to hold multiple types of animantion to occur at the
								// same time: translations and rotation.
								var rockMoveAndRoll:Parallel	= new Parallel(mRockArray[mNextRockToRoll]);
								
								if (mPlayAutomatically)
								{
									// Speed up roll duration on batch game play.
									rockMoveAndRoll.duration	= 0;
								}
								else
								{
									// Roll takes maximum of 2 seconds, based on actual distance.
									rockMoveAndRoll.duration	= 5000 * (singleRollDistance / 250);
								}
								
								// Do the translation of the rock.
								rockMove.xTo		= this.shuffleCourt.distanceToXPosition(singleRollDistance);
								
								// Do the rotation of the rock.
								var rotations:uint		= 
									singleRollDistance / mRockArray[mNextRockToRoll].getCircumference();
								var rockRotate:Rotate	= new Rotate(mRockArray[mNextRockToRoll]);
								rockRotate.easer 		= stopSlowly;
								rockRotate.angleBy		= rotations * 360;
								
								// Rotate around center of rock.
								rockRotate.transformX	= mRockArray[mNextRockToRoll].getPositionX();
								rockRotate.transformY	= mRockArray[mNextRockToRoll].getPositionY();
								rockRotate.transformZ	= 0;
								
								rockMoveAndRoll.addChild(rockMove);
		//						rockMoveAndRoll.addChild(rockRotate);
								
								if(mPlayAutomatically)
								{
									onRockRollComplete(new EffectEvent(EffectEvent.EFFECT_END));
								}
								else
								{
									// Send notification when play has completed. Used to disable/enable buttons.
									rockMoveAndRoll.addEventListener(EffectEvent.EFFECT_END, onRockRollComplete);
									rockMoveAndRoll.play();	// Play instantly vs. in sequence, like scattershot.
								}
							}
//							trace("Gamecount: " + gameCount);
							
							// Save data on this individual roll for TinkerPlots/Fathom.
							// Order in array is incremented by one so that first rock is number 1 vs. 0.
							mRollDataArray[mNextRockToRoll] = 
									new RollData(	mCurrentGameSinceLaunch,
													mNextRockToRoll + 1,
													whichCourt,
													mRockArray[mNextRockToRoll].getColor(),
													mRockArray[mNextRockToRoll].getPattern(),
													mRockArray[mNextRockToRoll].getShape(),
													mRockArray[mNextRockToRoll].getSize(),
													Math.floor(strength / 2),					// Strength used in calculation = twice slider value.
													singleRollDistance,
													singleRollScore);
	
							mMostRecentRockRolled = mNextRockToRoll; // Keep track of most recent rock rolled.
							mNextRockToRoll += 1;	// Roll is done and tracked. Increment counter.
						}	// for( i=rock 0 to n)
						
						// Save the strengths for later transmission to TinkerPlots/Fathom.
						if (!mPlayAutomatically)	
						{	var arrayIndex:Number = Math.floor((mMostRecentRockRolled + 1)/ROCKS_TO_ROLL) - 1;
							
							if ((mMostRecentRockRolled + 1) <= (NUMBER_OF_ROCKS / 2))
								// Top strength slider is relevant for rolls in the top court.
								mStrengthArray[arrayIndex] = mStrengthSliderA.value;
							else
								// Bottom strength slider is relevant for rolls in the bottom court.
								mStrengthArray[arrayIndex] = mStrengthSliderB.value;
						}
						else
						{
							// All A and B roll strengths for the entire game are the same, when
							// playing multiple games at once.
							for (var thisIndex:Number = 0; thisIndex < mStrengthArrayLength; ++thisIndex)
							{
								if ((thisIndex + 1) <= (mStrengthArrayLength / 2))
									// Top strength slider is relevant for rolls in the top court.
									mStrengthArray[thisIndex] = mStrengthSliderA.value;
								else
									// Bottom strength slider is relevant for rolls in the bottom court.
									mStrengthArray[thisIndex] = mStrengthSliderB.value;
							}
						}
						
						if(mPlayAutomatically)
						{
							// Send data for each individual roll to TinkerPlots/Fathom/DG.
							var numRocksToSend:int = mNextRockToRoll - mNextRockToSend;
							
							sendEventData( mRollDataArray, mNextRockToSend, mNextRockToRoll ); // send rocksToRoll events (max is NUMBER_OF_ROCKS)
//							tempA.push(mNextRockToSend);
//							tempB.push(mNextRockToRoll);
							
							mNextRockToSend = mNextRockToRoll;
						}
						
						// Reset "next rock to roll" back to first rock, if we have moved past the end of the rocks.
						if (mNextRockToRoll >= NUMBER_OF_ROCKS)
						{
							if(mPlayAutomatically)
							{
								mNextRockToRoll				= 0;		// Reset rock back to first rock.
								mNextRockToSend				= 0;	// Start with first rock.
								mRollRocksButton.enabled	= false;	// Can't roll again until new game button is pressed.
								enableStrengthSliderAAndLabel(false);	// Can't roll again until new game button is pressed.
								enableStrengthSliderBAndLabel(false);	// Can't roll again until new game button is pressed.
								
								// Set strength values used for transmission to TinkerPlots/Fathom when in
								// autoplay mode.
								var strengthTop:String		= mStrengthSliderA.value.toString(); 
								var strengthBottom:String	= mStrengthSliderB.value.toString(); 
								
								// Send data on this game to TinkerPlots/Fathom/DG.
								trace("later in onRollRocksMouseUp()");
								sendGameDataClose( strengthTop, strengthBottom, mStrengthArray );
								
								// Calculate the average game score when in batch mode.
								cumulativeBatchScore	+= mCurrentGameScore;
								mCurrentAverageScore	= Math.floor(cumulativeBatchScore/gameCount);
								
								//add current average score to graph
								this.graph.addDataPoint([gameCount, mCurrentAverageScore]);
								trace("adding data point: [",[gameCount, mCurrentAverageScore],"]");
								
								mMostRecentGamePlayed	= gameCount;	// Keep track of most recent game played.
								//mCurrentGameSinceLaunch += 1; 			// Game is done and tracked. Increment counter.
								mPrevLevel 				= mGameLevel;	// Track game level change.
							}
						}
						
					}	// for game = 0 to n
					this.graph.displayGraph(); //display graph for this set of games
					trace("displayGraph()");
					
//					/**
//					 * Code to send small chunks of data to dg at a time
//					 */
//					var intID:uint = setInterval(sendChunk, 1000);
//					const chunkSize:int = 16;
//					var start:int=1, end:int=chunkSize;
//					function sendChunk():void
//					{
//						for(var i:int=start; i<=end && i<=tempA.length; i++)
//						{
//							sendEventData(mRollDataArray, tempA[i],tempB[i]);
//							trace("RockRoll.sendChunk()",i);
//							
//						}
//						start+=chunkSize;
//						end+=chunkSize;
//						if(end>mNumberGamesStepper.value) end=mNumberGamesStepper.value;
//						if(start>=end){
//							clearInterval(intID);
//							tempA = new Array();
//							tempB = new Array();
//							trace("sendChunk done");
//							Alert.show("done");
//						}
//					} //End sendChunk()					
				}
				catch(e:ScriptTimeoutError)
				{
					trace(e);    	// ScriptTimeoutError: Error #1502: A script has executed for longer than 15 seconds
					errorHandler();	// Handle error
				}
				
			}
			
			// onSortRocks() is called when mSortRocksList is pressed and handles the
			// sorting of rocks and any corresponding UI changes.
			protected function onSortRocks(iEvent:IndexChangeEvent):void
			{
				// Update anything that may respond to changes in rock sort.
				this.updateStrengthSliders();
				this.updateCourtMarkings();
					
				// Sort rocks according to user selection.
				if (mSortRocksList.selectedIndex == DO_NOT_SORT)
					this.randomizeRockOrder();
				else
					this.sortRockArray(mSortRocksList.selectedIndex);
				
				// Redraw rocks in their new positions.
				this.redrawAllRocks();
			}
			
			// toggleCancelButton() toggles 'cancel'/'new game' state and button text.
			protected function toggleCancelButton():void
			{
				mCancelButtonOn			= !mCancelButtonOn;
				mNewGameButton.label	= mCancelButtonOn ? "Cancel" : "New Game";
			}
			
			// onNewGame() is called when mNewGameButton is pressed and handles
			// the setup of a new game.
			protected function onNewGame(iEvent:MouseEvent):void
			{
				// User pressed 'Cancel' during a game. Disable controls until user intiates new game.
				if (mCancelButtonOn) 
				{
					cancelPressed();
				}
				else // Handle the setup of a new game
				{
					resetRocks(); // Move all rocks back to starting point. 
					
					mNextRockToRoll				= 0;				// Start with first rock.
					mMostRecentRockRolled		= 0;				// Reset tracker of most recent rock rolled.
					mMostRecentGamePlayed		= 0;				// Reset tracker of most recent game played.
					mCurrentGameScore			= 0;				// Zero out current game score.
					enableStrengthSliderAAndLabel(true);			// Enable strength A slider
					enableStrengthSliderBAndLabel(true);			// Enable strength B slider
					enableAutoPlayCheckBoxAndLabel(true);			// Enable autoplay checkbox and label.
//					mNewGameButton.enabled		= false;			// Disable 'New Game' button.
					mChangeLevelButton.enabled	= false;			// Disable "Change Level" button.
					mScoreTextLabel.text		= "Score = 0";		// Reset score to zero.
					mRollCounter				= 0;				// Reset roll animation counter.

					if (mPlayAutomatically)
						enableNumberGamesStepperAndLabel(true);		// Enable the number of games stepper.
					
					// Send data on this game to TinkerPlots/Fathom/DG.
					if( mLastGameOpenState == kGameDataClosed ) {
						mLastGameOpenState = kGameDataNotYetOpen;
						sendGameDataOpen();
					}
				}
				
				// Toggle 'cancel'/'new game' state and button text.
				toggleCancelButton();
				
				// Update instructions text.
				updateInstructionsText();
				
			}
			
			protected function cancelPressed():void
			{
				mRollRocksButton.enabled	= false;	// Disable Roll Rocks button until rocks are done rolling.
				enableStrengthSliderAAndLabel(false);	// Disable strength slider
				enableStrengthSliderBAndLabel(false);	// Disable strength slider
				enableAutoPlayCheckBoxAndLabel(false);	// Disable autoplay checkbox and label.
				enableNumberGamesStepperAndLabel(false);// Disable games-to-play counter until new game is started.
				enableSortRocksList(false);		// Disable sort feature until new game is started.
				
				// close the open game case (for DG)
				if( mCurrentGameSinceLaunch == mLastGameOpened ) { 
					// Set strength values used for transmission to TinkerPlots/Fathom when in
					// autoplay mode.
					var strengthTop:String		= mStrengthSliderA.value.toString(); 
					var strengthBottom:String	= mStrengthSliderB.value.toString(); 
					
					// Send data on this game to TinkerPlots/Fathom/DG.
					trace("cancelPressed()");
					sendGameDataClose( strengthTop, strengthBottom, mStrengthArray );
					
					mCurrentGameScore	= 0; // Zero out score on new game.
					mTopGameScore		= 0; // Zero out score on new game.
					mBottomGameScore	= 0; // Zero out score on new game.
				}
				
				resetRocks(); // Move all rocks back to starting point.
			}
			
			protected function resetRocks():void
			{
				// Move all rocks back to starting point.
				var startX:Number = 0;
				var startY:Number = 0;
				for (var i:uint = 0; i < NUMBER_OF_ROCKS; ++i)
				{
					// Do the actual rolling of the rock.
					var rockMove:Move = new Move(mRockArray[i]);
					rockMove.duration = 1000; // Roll duration in milliseconds.
					rockMove.xTo = startX;
					rockMove.yTo = startY;
					
					// Send notification when play has completed. Used to disable/enable buttons.
					rockMove.addEventListener(EffectEvent.EFFECT_END, onRockReturnComplete);
					
					rockMove.play();
				}
			}

			// onUpdateNumberOfGames() is called when mNumberGamesStepper is changed and 
			// issues a call to handle all associated changes.
			protected function onUpdateNumberOfGames(iEvent:Event):void
			{
				this.updateNumberOfGames();
			}

			// onChangeStrengthA is called when mStrengthSliderA is changed and issues a 
			// call to handle all associated changes.
			protected function onChangeStrengthA(iEvent:SliderEvent):void
			{
				this.changeStrengthA();
			}

			// onChangeStrengthB is called when mStrengthSliderB is changed and issues a 
			// call to handle all associated changes.
			protected function onChangeStrengthB(iEvent:SliderEvent):void
			{
				this.changeStrengthB();
			}

			// onAutoPlay() is called when the mAutoPlayCheckBox is toggled and handles
			// batch play of one or more games all at once at current settings for all
			// games.
			protected function onAutoPlay(iEvent:MouseEvent):void
			{
				if (mAutoPlayCheckBox.selected == true)
				{
					enableNumberGamesStepperAndLabel(true);
					mPlayAutomatically			= true;
					graph.visible = true;
				}
				else
				{
					enableNumberGamesStepperAndLabel(false);
					mPlayAutomatically			= false;
					mNumberGamesStepper.value	= 1;		// One game is played in non-batch mode.
					graph.visible = false;
				}
				
				// Handle anything associated with a change to the number of games.
				// Update of instruction text is included.
				updateNumberOfGames();		
			}

			// onClickChangeLevelButton() allows the user to change the game level.
			protected function onClickChangeLevelButton(iEvent:MouseEvent):void
			{
				mLevelWindow = new GameLevelWindow();
				chooseGameLevel();
			}
			
//			protected function rollComplete()
			protected function updateGraph(e:EffectEvent):void
			{
				//this.graph.score.text = "Avg Score: " + mCurrentAverageScore;
//				this.graph.displayGraph();
			}

		]]>
	</fx:Script>
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<!-- Interface Elements: StatusBar, PlayerControls, ShuffleCourt, Graph, and SortRocksList. -->
	<!-- StatusBar -->
	<s:BorderContainer id="StatusBar" x="5" y="0" width="{this.width - 10}" height="30" cornerRadius="3">
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0xf0f0f0"/>
				<s:GradientEntry color="0xd8d8d8"/>
			</s:LinearGradient>
		</s:backgroundFill>
		<s:Label x="6" y="4" text="Level One" id="mLevelLabel" fontSize="16" color="#000000" textAlign="center" height="21" verticalAlign="middle"/>
		<s:RichText text="ROCK ROLL" id="mGameTitle" fontFamily="Verdana" fontSize="20" color="#4E594E" x="120" y="6" width="559" textAlign="center" verticalAlign="top" height="28" fontStyle="normal" textDecoration="none" fontWeight="normal" backgroundAlpha="1.0"/>
		<s:Label id="mVersionLabel" x="610" y="8" width="172" color="#4E594E" initialize="mVersionLabel.text=getVersion()" textAlign="right"/>
		<!-- //TODO: Volume slider from chainsaw: -->
		<!--
		<s:Image id="mVolumeImage" x="620" y="6" source="{mVolumeIcon}"/>
		<s:HSlider id="mVolumeSlider" x="645" y="9" width="80" change="updateVolume(mVolumeSlider.value)" dataTipPrecision="0" maximum="100" value="100"/>
		-->
	</s:BorderContainer>
	
	<!-- PlayerControls. Holds all interface elements to the left of ShuffleCourt. -->
	<s:BorderContainer id="PlayerControls" x="5" y="35" width="223" height="355" cornerRadius ="3" borderVisible="true" backgroundColor="#93ae93">
		<s:Button x="10" y="5" label="New Game" width="87" id="mNewGameButton" enabled="true" click="onNewGame(event)" height="22"/>
		<s:Button x="116" y="5" label="Change Level" id="mChangeLevelButton" click="onClickChangeLevelButton(event)" height="22"/>
		<s:CheckBox x="12" y="40" id="mAutoPlayCheckBox" height="18" selected="false" enabled="false" click="onAutoPlay(event)" width="15"/>
		<s:Label x="27" y="43" text="AutoPlay Entire Game(s)" id="mAutoPlayLabel" width="90" textAlign="center" color="#4E594E"/>
		<s:NumericStepper x="126" y="40" minimum="1" maximum="100" stepSize="1" id="mNumberGamesStepper" change="onUpdateNumberOfGames(event)" height="23" width="84" enabled="false"/>
		<s:Label x="126" y="61" text="Games to Play" verticalAlign="middle" height="23" color="#4E594E" width="84" id="mNumberGamesStepperLabel"/>
		<mx:HSlider x="10" y="80" width="200" id="mStrengthSliderA" minimum="1" maximum="100" enabled="false" liveDragging="true" change="onChangeStrengthA(event)" value="100" tickInterval="10" labels="[1, 50, 100]" snapInterval="1"/>
		<s:Label x="36" y="129" text="Strength A" id="mStrengthLabelA" width="204" verticalAlign="middle" textAlign="left" fontFamily="Verdana" color="#4E594E" fontSize="10"/>
		<s:Button x="9" y="198" label="Roll Rocks" id="mRollRocksButton" enabled="false" width="108" mouseDown="onRollRocksMouseDown(event)" mouseUp="onRollRocksMouseUp(event)" height="22"/>
		<mx:HSlider x="10" y="250" width="200" id="mStrengthSliderB" minimum="1" maximum="100" enabled="false" liveDragging="true" change="onChangeStrengthB(event)" value="100" tickInterval="10" labels="[1, 50, 100]" snapInterval="1"/>
		<s:Label x="28" y="299" text="Strength B" id="mStrengthLabelB" width="204" verticalAlign="middle" textAlign="left" fontFamily="Verdana" color="#4E594E" fontSize="10"/>
		<s:Label x="10" y="314" text="Score = 0" id="mScoreTextLabel" color="#DEEBDE" fontSize="20" width="200" textAlign="center" fontWeight="bold"/>
		<s:Label x="8" y="335" text="Press 'New Game' Button to Begin" width="206" height="16" verticalAlign="middle" color="#FFFFFF" textAlign="center" id="mInstructionsLabel"/>
	</s:BorderContainer>
	
	<!-- ShuffleCourt. Seperate MXML file defining the court interface. -->
	<default:ShuffleCourt x="233" y="58" id="shuffleCourt" fontFamily="Verdana">
	</default:ShuffleCourt>
	
	<!-- Graph. Replaces ShuffleCourt when playing multiple games to view trends in score in each game. --> 
	<default:Graph x="233" y="58" id="graph" visible="false">
	</default:Graph>
	<!-- <s:SpriteVisualElement id="mSpriteVE" /> -->
	
	<!-- SortRocksList. Dropdown list for sorting rocks by color, shape, pattern, or size. -->
	<s:DropDownList x="233" y="35" width="90" enabled="false" change="onSortRocks(event)" prompt="Sort Rocks by ..." labelField="text" id="mSortRocksList" selectedIndex="0" dataProvider="{sortList}"></s:DropDownList>
	
	<!-- <mx:ProgressBar x="10" y="353" id="mScoreBar" mode="manual" width="200" fontWeight="normal" label="0%" textAlign="center" labelPlacement="center" fontSize="14" color="#FFFFFF"/> -->

	
	<!-- MovieContainer -->
	<s:BorderContainer id="MovieContainer" x="0" y="0" width="{this.width}" height="{this.height}" borderVisible="true" backgroundColor="#93ae93">
		<s:MovieClipSWFLoader id="introMovie" x="0" y="0" width="{this.width}" height="{this.width}" source="/src/rockroll_assets/intro-movie.swf"/>
		<s:SWFLoader id="playButton" x="340" y="300" width="120" height="43" complete="initPlayButton()"  source="/src/rockroll_assets/play_btn.swf"/>
	</s:BorderContainer>  

	<!-- Error message for bad version of flash player -->	
	<s:BorderContainer id="BrickWall"	x="0" y="0" width="800" height="400" visible="false">
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0xFF0000"/>
				<s:GradientEntry color="0xB40404"/>
			</s:LinearGradient>
		</s:backgroundFill>
		
		
		<s:Label id="topLabelError" text="You are using an outdated version of Adobe Flash Player." x="0" y="80"  fontSize="20" fontFamily="Arial" fontWeight="bold" textAlign="center" width="800" color="0xffffff"/>
		<s:Label id="midLabelError" text="{'RockRoll requires Flash Player '+ MINIMUM_REQUIREMENTS +' or later.'}" x="0" y="170"  fontSize="15" fontFamily="Arial" textAlign="center" width="800" color="0xffffff"/>
		<s:Label id="midLabel2Error" text="{'You are currently using Flash Player ' + VersionChecker.getVersion()}" x="0" y="190"  fontSize="15" fontFamily="Arial" textAlign="center" width="800" color="0xffffff"/>
		<s:Label id="bottomLabel" text="Download the latest version at http://get.adobe.com/flashplayer/" x="0" y="310"  fontSize="15" fontFamily="Arial" textAlign="center" width="800" color="0xffffff"/>
	</s:BorderContainer>

</s:Application>